# 第11章 《使用类》 编程练习题之我解

## 11.1

**题** 修改程序清单11.5，使之将一系列连续的随机漫步者位置写入 到文件中。对于每个位置，用步号进行标示。另外，让该程序将初始条 件(目标距离和步长)以及结果小结写入到该文件中。该文件的内容与 下面类似:

![image-20220213121523370](https://static.fungenomics.com/images/2022/02/image-20220213121523370.png)

## 11.2

**题：** 对Vector类的头文件(程序清单11.13)和实现文件(程序清单 11.14)进行修改，使其不再存储矢量的长度和角度，而是在magval( )和 angval( )被调用时计算它们。

应保留公有接口不变(公有方法及其参数不变)，但对私有部分 (包括一些私有方法)和方法实现进行修改。然后，使用程序清单 11.15对修改后的版本进行测试，结果应该与以前相同，因为Vector类的 公有接口与原来相同。

## 11.3

**题：** 修改程序清单11.15，使之报告N次测试中的最高、最低和平均 步数(其中N是用户输入的整数)，而不是报告每次测试的结果。

## 11.4

**题：** 重新编写最后的Time类示例(程序清单11.10、程序清单11.11和 程序清单11.12)，使用友元函数来实现所有的重载运算符。

## 11.5 

**题：** 重新编写Stonewt类(程序清单11.16和程序清单11.17)，使它 有一个状态成员，由该成员控制对象应转换为英石格式、整数磅格式还 是浮点磅格式。重载<<运算符，使用它来替换show_stn( )和show_lbs( ) 方法。重载加法、减法和乘法运算符，以便可以对Stonewt值进行加、 减、乘运算。编写一个使用所有类方法和友元的小程序，来测试这个类。



## 11.6

**题：** 重新编写Stonewt类(程序清单11.16和程序清单11.17)，重载 全部6个关系运算符。运算符对pounds成员进行比较，并返回一个bool 值。编写一个程序，它声明一个包含6个Stonewt对象的数组，并在数组 声明中初始化前3个对象。然后使用循环来读取用于设置剩余3个数组元 素的值。接着报告最小的元素、最大的元素以及大于或等于11英石的元 素的数量(最简单的方法是创建一个Stonewt对象，并将其初始化为11 英石，然后将其同其他对象进行比较)。

## 11.7

**题：** 复数有两个部分组成:实数部分和虚数部分。复数的一种书写 方式是:(3.0，4.0)，其中，3.0是实数部分，4.0是虚数部分。假设a = (A, Bi)，c = (C, Di)，则下面是一些复数运算。

* 加法: `a + c = (A+C, (B+D)i)`;
* 减法: `a – c = (A−C, (B−D)i)`;
* 乘法: `a * c = (A*C−B*D, (A*D + B*C)i)`;
* 乘法:: `x*c = (x * C, x *Di)`，其中 `x` 为实数;
* 共轭: `~a = (A, −Bi)`。

请定义一个复数类，以便下面的程序可以使用它来获得正确的结果。

![image-20220213122324123](https://static.fungenomics.com/images/2022/02/image-20220213122324123.png)

![image-20220213122343507](https://static.fungenomics.com/images/2022/02/image-20220213122343507.png)

![image-20220213122410552](https://static.fungenomics.com/images/2022/02/image-20220213122410552.png)

注意，必须重载运算符<<和>>。标准C++使用头文件complex提供 了比这个示例更广泛的复数支持，因此应将自定义的头文件命名为 complex0.h，以免发生冲突。应尽可能使用const。

下面是该程序的运行情况。

![image-20220213122510816](https://static.fungenomics.com/images/2022/02/image-20220213122510816.png)

请注意，经过重载后，cin >>c将提示用户输入实数和虚数部分。



